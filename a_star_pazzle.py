# -*- coding: utf-8 -*-

from itertools import product
import copy
import time

start = time.time()

# find where space is. space means 0.
def space_founder(board):
    for x, y in product(range(3), range(3)):
        if board[x][y] is 0:
            return x, y

# calculate for heuristic.
def manhattan(board_now, board_goal):
    cost = 0
    for x, y, goal_x, goal_y in product(range(3), range(3), range(3), range(3)):
        if board_now[x][y] == board_goal[goal_x][goal_y]:
            cost += abs(x - goal_x) + abs(y - goal_y)
    return int(cost/2)            

directions = [(0, 1), (1, 0), (-1, 0), (0, -1)]

# Create a node with spaces and adjacent nodes interchanged.
def replace(node, direction):
    n = copy.deepcopy(node)
    x, y = n.space
    try: n.board[x][y], n.board[x + direction[0]][y + direction[1]] = n.board[x + direction[0]][y + direction[1]], n.board[x][y]
    except: pass
    # "continue" if next move was out of range.
    return n.board

def list_matcher(list1, list2):
    for x, y in product(range(3), range(3)):
        if list1[x][y] != list2[x][y]: return False
    return True

# Display a result.
def print_answer(x, num):
    if x is not None:
        num += 1
        print_answer(x.parent_node, num)
        if num > 0:
            print("To the Goal : ", num, "hand")
        else:
            print("ーーーGoalーーー")
        print(x.board[0])
        print(x.board[1])
        print(x.board[2])
        print("")
        print("")



# All states are generated by this class.
class Node():
    start = None
    goal = None
    def __init__(self, board):
        self.board = board
        self.space = space_founder(self.board)
        self.parent_node = None
        self.h_star = manhattan(self.board, self.goal)
        self.f_star = 0

    def __getitem__(self, item):
        return self.board[item]

# Find the state "n" specified by the method "find" from the list "OPEN" and the 
# list "CLOSE", and delete the specified state "node" with the method "remove".
# 「OPEN」  -> List of deployable nodes
# 「CLOSE」 -> List of expanded nodes
class NodeList(list):
    # If there is the same node as the node passed from the 0th in the list "self", it returns "Node" object,
    # otherwise it returns "None".
    def find(self, n):
        for t in range(len(self)):
            if list_matcher(self[t].board, n.board):
                l = self[t]
                if l != []: return l
            else: return None

    def remove(self,node):
        del self[self.index(node)]

# Settings of the "Start" and "Goal".

Node.start = [
    [0, 2, 3],
    [1, 5, 6],
    [4, 7, 8]
]

Node.goal = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 0]
]

Start = Node(copy.deepcopy(Node.start))
Goal = Node(Node.goal)

# Since the initial value of f (n) is g (n) = 0, it coincides with h (n).
Start.f_star = Start.h_star

# Initial declaration of list "OPEN" and list "CLOSE"
openList = NodeList()
closeList = NodeList()

# Calculate the cost with the first argument as the current state and the second 
# argument as the next state
def fPrime(n, m):    
    # g*(n) = f*(n) - h*(n) can be obtained from the current state.
    gStar = lambda n, m: n.f_star - n.h_star
    hStar = lambda m: m.h_star
    cost = 1
    '''
    gStar -> Cost actually took up to the current state
    hStar -> Predicted cost to the goal when transitioning to the next state
    cost  -> The cost of moving from the current state to the next state
    '''
    return gStar(n, m) + hStar(m) + cost

# Start search with the node "start" in "OPEN".
openList.append(Start)

while openList:
    n = min(openList, key=lambda x: x.f_star)

    openList.remove(n)
    closeList.append(n)

    # If the node n included in the "OPEN" list is a goal, the search is ended.
    if list_matcher(n.board, Node.goal):
        end_node = n
        break
    
    for direction in directions:
        m = Node(replace(n, direction))

        # Check whether the node is included in "OPEN" and "CLOSE".
        om = openList.find(m)
        cm = closeList.find(m)
        
        # New node not included in "OPEN" or "CLOSE"
        fp = fPrime(n, m)

        # If m is included in "OPEN", execute above, if m is included in "CLOSE", execute below.
        om_fp = fPrime(n, om) if om else None
        cm_fp = fPrime(n, cm) if cm else None

        if om is None and cm is None:
            m.parent_node = n
            m.f_star = fp
            openList.append(m)
        elif not om is None and om_fp < om.f_star:
            om.parent_node = n
            om.f_star = om_fp
        elif not cm is None and cm_fp < cm.f_star:
            cm.f_star = cm_fp
            closeList.remove(cm)
            openList.append(cm)
        m = Node(replace(n, direction))
        # Finally we need to replace it again to create a new node from "direction".
else:
    print("The input board is a board which can not be solved. Please pay attention to the parity and input again.")


print_answer(n, -1)

print("End Time:",time.time() - start)
